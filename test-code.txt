import { Injectable } from '@angular/core';
import { Storage } from '@ionic/storage';
//import { SQLite, SQLiteObject } from '@ionic-native/sqlite';
import { Platform, ToastController } from 'ionic-angular';
//import { SqlResultSet } from './models/models';

@Injectable()
export class DbContext
{
    //public get database(): Promise<SQLiteObject>
    //{
    //    return new Promise<SQLiteObject>((resolve, reject) => {
    //        this.sqlite.create({ name: 'parliament.db', location: 'default' })
    //            .then((db: SQLiteObject) => {
    //                resolve(db);
    //            }).catch(e => {
    //                reject(e);
    //            });
    //        }).catch(e => {
    //            let toast = this.toast.create({
    //                message: 'error opening db :' + e,
    //                duration: 8000,
    //                position: 'bottom'
    //            });

    //            toast.present();
    //        });;
    //}

    constructor(public storage: Storage,
        private toast: ToastController,
        private platform: Platform) {

        this.platform.ready().then(() => {

            this.database.then((db: SQLiteObject) => {                    
                    this.createTables(db);
                    this.fullFillTables(db);
                }).catch(e => {
                    let toast = this.toast.create({
                        message: 'error :' + e,
                        duration: 8000,
                        position: 'bottom'
                    });

                    toast.present();
                });
        });
    }

    createTables(db: SQLiteObject): void {
        db.transaction(tx => {
            tx.executeSql(this.createPersonsTableScript, {});
            tx.executeSql(this.createImagesTableScript, {});
            tx.executeSql(this.createTracksTableScript, {});
        }).then(() => {
            let toast = this.toast.create({
                message: 'creating tables sucseed',
                duration: 8000,
                position: 'bottom'
            });

            toast.present();
        }).catch(e => {
            let toast = this.toast.create({
                message: 'error creating tables :' + e,
                duration: 8000,
                position: 'bottom'
            });

            toast.present();
        });
    }

    fullFillTables(db: SQLiteObject): void {
        db.transaction(tx => {
            tx.executeSql(this.fullFillPersonsTableScript, ["klichko", "mer"]);
        }).catch(e => {
            let toast = this.toast.create({
                message: 'full fill error :' + e,
                duration: 8000,
                position: 'bottom'
            });

            toast.present();
        });
    }

    //execute(statement: string, params: any[] = []): Promise<SqlResultSet> {
    //    return new Promise((resolve, reject) => {
    //        this._db.transaction(tx => tx.executeSql(statement, params, (tx, resultSet) => {
    //            resolve(resultSet);
    //        }, (tx, error) => {
    //            reject(error)
    //        }));
    //    });
    //}

    testReadPersons(): Promise<string> {
        return new Promise((resolve, reject) => {
            this.database.then(db => {
                db.transaction(tx => { 
                    tx.executeSql(this.getAllPersons, {}).then(rs => {
                        resolve('read sucseed :' + rs.rows.item(0).name);
                    }).catch(e => {
                        reject('query read error :' + e);
                    });
                }).catch(e => {
                    reject('transaction lalala :' + e);
                });
            });
        });
    }

    get createPersonsTableScript() : string {
        return "CREATE TABLE IF NOT EXISTS Persons " +
            "(Id int primary key," +
            "Name text," +
            "Post text)";
    }

    get createImagesTableScript() : string {
        return "CREATE TABLE IF NOT EXISTS ImageInfo " +
            "(Id int primary key," +
             "MainPicPath text," +
             "SmallButtonPicPath text," +
             "ListButtonPicPath text," +
             "PersonId int," +
             "FOREIGN KEY(PersonId) REFERENCES Persons(Id))";
    }

    get createTracksTableScript() : string {
        return "CREATE TABLE IF NOT EXISTS Tracks " +
            "(Id int primary key," +
            "Name text," +
            "Path text," +
            "YouTubeLink text," +
            "Rating real," +
            "IsTrackLocked int," +
            "IsYouTubeLinkLocked int," +
            "PronauncingDate text," +
            "PersonId int," +
            "FOREIGN KEY(PersonId) REFERENCES Persons(Id))";
    }

    get fullFillPersonsTableScript() : string {
        return "insert into Persons (name, post) values (?,?)";
    }

    get getAllPersons(): string{
        return "select name, post from Persons";
    }
}